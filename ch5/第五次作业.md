# 第五次作业



## 第一题：无信息







## 第二题： ORB特征点





​	先要装tbb和升级gcc



### 2.1 orb提取



```c++
    vector<cv::KeyPoint> keypoints;
    cv::FAST(first_image, keypoints, 40);
    cout << "keypoints: " << keypoints.size() << endl;
```



![image-20221003145852757](/home/cp/.config/Typora/typora-user-images/image-20221003145852757.png)

### 2.2 orb描述



旋转不变性

```c++
void computeAngle(const cv::Mat &image, vector<cv::KeyPoint> &keypoints) {
    int half_patch_size = 8;
    for (auto &kp : keypoints) {
        // START YOUR CODE HERE (~7 lines)
        int u = kp.pt.x, v = kp.pt.y;

        //判断是否出界，并选择是否跳出
        if(u>=half_patch_size&&v>=half_patch_size&&u<=image.cols-half_patch_size &&v <=image.rows-half_patch_size)
        {
            int m01=0, m10=0;
            for (int i = u-half_patch_size+1; i < u+half_patch_size-1; ++i) {
                for (int j = v-half_patch_size+1; j < v+half_patch_size-1; ++j) {
                    m10 += i * image.at<uchar>(j,i);
                    m01 += j * image.at<uchar>(j,i);
                }
            }
            //atan会返回弧度制的旋转角,但 OpenCV 中使用角度制,需要进行弧度转换
            kp.angle = (float)atan(m01/m10)*180/pi;
        }
        // END YOUR CODE HERE
    }
    return;
}
```



计算描述子



```c++
void computeORBDesc(const cv::Mat &image, vector<cv::KeyPoint> &keypoints,vector<DescType> &desc) {
    for (auto &kp : keypoints) {
        DescType d(256, false);
        for (int i = 0; i < 256; i++) {
            // START YOUR CODE HERE (~7 lines)
            //判断旋转前是否出界，并计算旋转后的p、q坐标
            int u = kp.pt.x, v = kp.pt.y;
            if(u-8>=0 && v-8>=0 && u+7 <= image.cols && v+7 <= image.rows)
            {
                //角度转弧度
                double theta = kp.angle*pi/180;
                int u_p_ = (int)(ORB_pattern[i*4] * cos(theta) - ORB_pattern[i*4+1]* sin(theta)) + u;
                int v_p_ = (int)(ORB_pattern[i*4] * sin(theta) + ORB_pattern[i*4+1]* cos(theta)) + v;
                int u_q_ = (int)(ORB_pattern[i*4+2] * cos(theta) - ORB_pattern[i*4+3]* sin(theta)) + u;
                int v_q_ = (int)(ORB_pattern[i*4+2] * sin(theta) + ORB_pattern[i*4+3]* cos(theta)) + v;
                //判断根据关键点得到的经过旋转的p、q是否出界
                if(u_p_<0 || v_p_<0 || u_p_ >image.cols || v_p_ > image.rows || u_q_<0 || v_q_<0 || u_q_ >image.cols || v_q_ > image.rows){
                    d.clear();
                    break;
                }
                d[i] = image.at<uchar>(v_p_,u_p_) > image.at<uchar>(v_q_, u_q_) ? false : true;

            }else{
                d.clear();
            }
            // END YOUR CODE HERE
        }
        desc.push_back(d);
    }

    int bad = 0;
    for (auto &d : desc) {
        if (d.empty())
            bad++;
    }
    cout << "bad/total: " << bad << "/" << desc.size() << endl;
    return;
}
```







### 2.3 暴力匹配



```c++
void bfMatch(const vector<DescType> &desc1, const vector<DescType> &desc2,
             vector<cv::DMatch> &matches) {
    int d_max = 50;
    // START YOUR CODE HERE (~12 lines)
    // find matches between desc1 and desc2.
    //遍历描述子p
    for (int i=0; i<(int)desc1.size(); i++)
    {
        int min_distance = 256, index = 0; //设置一个最小的距离
        if(desc1[i].empty()) continue;
        for (int j = 0; j < (int)desc2.size(); ++j) {
            if(desc2[j].empty()) continue;
            int hanming_distance = 0;
            //计算两个描述子的汉明距离
            for(int k=0; k<256; k++){
                hanming_distance += desc1[i][k]^desc2[j][k];
                //cout<<hanming_distance<<endl;
            }
            if (hanming_distance < min_distance) {
                min_distance = hanming_distance;
                index = j;
            }
        }
        //阈值筛选，最大距离为50
        if(min_distance <= d_max)
        {
            cv::DMatch match;
            match.distance = min_distance;
            match.queryIdx = i;
            match.trainIdx = index;
            matches.push_back(match);
        }
    }
```





![image-20221003145824344](/home/cp/.config/Typora/typora-user-images/image-20221003145824344.png)

### 2.4 多线程orb









## 第三题 从E恢复R，t



### 3.1 对E作SVD分解









### 3.2 处理∑的奇异值









### 3.3 共存的四个可能的解







![image-20221003154102309](/home/cp/.config/Typora/typora-user-images/image-20221003154102309.png)









## 第四题： 用G-N实现Bundle Adjustment中的位姿估计





![image-20221003162110301](/home/cp/.config/Typora/typora-user-images/image-20221003162110301.png)







## 第五题： 用ICP实现轨迹对齐































































## 参考链接



2

https://blog.csdn.net/qq_39779233/article/details/126284595?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-126284595-blog-112864330.pc_relevant_layerdownloadsortv1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-126284595-blog-112864330.pc_relevant_layerdownloadsortv1&utm_relevant_index=112.1

2.1

















## 结语